1. Что такое git? Что хранится в папке .git?
Git — система контроля версий, а в папке .git хранятся данные репозитория Git.
2. Из-за чего возможна переносимость приложений на java между различными ОС?
Переносимость приложений на Java между различными ОС возможна благодаря
виртуальной машине Java (JVM).
3. Полиморфизм, инкапсуляция, наследование
Полиморфизм, инкапсуляция и наследование — три основных принципа объектноориентированного программирования (ООП). Эти принципы помогают создавать гибкие,
масштабируемые и легко поддерживаемые программы.
4. Типы данных. Статическая типизация
Статическая типизация — приём в языках программирования, при котором переменная,
параметр подпрограммы или возвращаемое значение функции связываются с типом в
момент объявления, и тип не может быть изменён позже.
5. Структура программы на java
Структура программы на языке Java включает несколько элементов, которые обеспечивают
порядок и читаемость кода.
Объявление пакета, Определение класса, Метод main() — точка входа, Инструкции и блоки
кода, Комментарии
6. Выполнение программы. Метод main
Метод main в Java — основной элемент каждой программы, с него начинается выполнение кода.
Без корректного объявления метода программа не сможет запуститься.
7. Переменные и константы
Переменные и константы — ключевые понятия в программировании, которые помогают
хранить и управлять данными в коде.
Переменная — это именованная область памяти, в которой хранится некоторое значение. Она
позволяет сохранить данные (число, текст, результат вычислений) и использовать их позже.
Константа — это переменная, значение которой не может быть изменено после её
инициализации. Она используется для хранения значений, которые не должны изменяться в
течение работы программы, например, математических констант, параметров программы или
контрольных значений.
8. Преобразование типов данных. Явное и неявное преобразование
Преобразование типов данных в программировании может быть неявным и явным. Эти
понятия описывают два способа конвертации данных из одного типа в другой.
Неявное преобразование происходит автоматически, без явного указания программиста.
Компилятор изменяет тип данных одного выражения на другой, основываясь на контексте
операции.
Явное преобразование (приведение типов) требует прямого указания программистом, как
изменить тип данных. Это даёт больший контроль над процессом и помогает избежать ошибок,
связанных с автоматическим преобразованием.
9. Преобразование типов данных. Правила
Преобразование типов данных в программировании может быть неявным (автоматическим)
или явным (требует явного указания).
Некоторые правила неявного преобразования типов:
Арифметические операции: меньший тип автоматически преобразуется в больший. Например, при
сложении int и double тип int преобразуется в double.
Преобразования при присваивании: значение одного типа автоматически преобразуется в тип
переменной. Например, при присваивании double значению int дробная часть отбрасывается.
Преобразования при передаче аргументов: когда аргумент функции имеет тип, отличный от типа
параметра, аргумент преобразуется в тип параметра.
10. Консольный ввод/вывод
Консольный ввод/вывод — это взаимодействие программы с пользователем через текстовый
интерфейс (консоль). В программировании для этого используются специальные функции,
которые позволяют считывать данные с клавиатуры и выводить их на экран.
11. Унарная, бинарная, тернарная операция
Унарная, бинарная и тернарная операции — это типы операций в программировании, которые
различаются по количеству принимаемых аргументов.
Унарная операция принимает один аргумент. Примеры: отрицание, унарный минус
Бинарная операция требует двух аргументов. К таким операциям относятся, например,
сложение, вычитание, умножение.
Тернарная операция принимает три аргумента. Пример: условная операция «условие ?
выражение1 : выражение2»
12. Арифметические операции
Арифметические операции — это основные математические действия, которые выполняют с
числами: сложение, вычитание, умножение и деление.
Сложение
Вычитание
Умножение
Деление
13. Условные выражения и логические операции
Условные выражения в программировании позволяют выполнять определённые блоки кода в
зависимости от выполнения условий. Для создания сложных условий используются операции
сравнения и логические операторы.
Некоторые операции сравнения:
Равенство (==) — проверяет, равны ли два значения.
Неравенство (!=) — проверяет, не равны ли два значения.
Больше (>) — проверяет, больше ли первое значение второго.
Меньше (<) — проверяет, меньше ли первое значение второго.
Больше или равно (>=) и меньше или равно (<=) — проверяют, больше или равно ли первое значение
второму или меньше или равно ему.
14. Условные конструкции в java
В языке Java используются три условные конструкции: if, if-else и switch. Они позволяют
управлять потоком выполнения программы на основе условий
Оператор if проверяет истинность условия и, если оно истинно, выполняет блок кода. Если
условие ложно, блок не выполняется.
Оператор if-else выполняет один блок кода, если условие истинно, и другой блок — если
условие ложно.
Оператор switch позволяет выбрать один из нескольких блоков кода на основе значения
переменной.
15. Циклы в java. Операторы прерывания
В языке Java для управления потоком выполнения циклов используются операторы
прерывания — break и continue. Они позволяют завершить цикл раньше или пропустить
текущую итерацию.
Break позволяет преждевременно завершить цикл и передать управление следующему
оператору.
Continue позволяет пропустить оставшуюся часть тела цикла и немедленно перейти к
следующей итерации.
16. Массивы в java
Массивы в Java — это структура данных, которая позволяет хранить множество элементов
одного типа. Каждый элемент доступен по индексу, отсчёт начинается с нуля.
Синтаксис объявления массива в Java:
тип_элементов имя_массива;
17. Сортировка массивов. Метод пузырька
Сортировка пузырьком (Bubble Sort) — простой алгоритм сортировки, который основан на
последовательном сравнении соседних элементов и их обмене местами, если порядок неверен.
Принцип работы
Алгоритм состоит из повторяющихся проходов по массиву. За каждый проход элементы сравниваются
попарно, и если порядок в паре неверный, выполняется перестановка элементов. habr.com
После первого прохода самый большой элемент оказывается в конце массива. Затем процесс
повторяется для оставшейся части массива, исключая уже отсортированные элементы, до тех пор, пока
весь массив не будет отсортирован. dzen.ruznanierussia.rusprintcode.pro
Название алгоритма происходит от принципа работы: элементы как бы «всплывают» к нужной позиции,
подобно пузырькам воздуха в воде.
18. Сортировка массивов. Шейкерная сортировка
Шейкерная сортировка (Shaker Sort, двунаправленная пузырьковая сортировка) — алгоритм
сортировки массивов, который представляет собой модификацию классического пузырькового метода.
Он работает по принципу перемещения элементов в обе стороны (вверх и вниз) по массиву, что
позволяет более эффективно упорядочивать данные. dzen.ru
Принцип работы:
Два прохода. Алгоритм выполняет два прохода по массиву: один — слева направо, другой — справа
налево.
Слева направо. На первом проходе алгоритм сравнивает соседние элементы и меняет их местами, если
они находятся в неправильном порядке (больший элемент слева от меньшего). Этот проход «поднимает»
наибольший элемент в конец массива.
Справа налево. На втором проходе алгоритм снова сравнивает соседние элементы, но теперь идёт
справа налево, «опуская» наименьший элемент в начало массива.
Повторение. Процессы продолжаются до тех пор, пока не будет выполнен полный проход без каких-либо
перестановок, что означает, что массив отсортирован.
19. Сортировка массивов. Сортировка расческой
Сортировка расчёской (англ. comb sort) — улучшение сортировки пузырьком. Её идея —
«устранить» элементы с небольшими значениями в конце массива, которые замедляют работу
алгоритма.
Алгоритм работы
В сортировке расчёской сравниваются не соседние элементы, а элементы, расположенные на
определённом расстоянии друг от друга. Первоначально расстояние выбирается большим —
например, равным размеру массива, разделённому на специальную величину — фактор уменьшения.
Оптимальное значение фактора уменьшения — 1,247
20. Сортировка массивов. Сортировка вставками
Сортировка вставками (Insertion Sort) — это алгоритм сортировки, который строит отсортированный
массив (или список) по одному элементу за раз. Он берёт каждый элемент из неотсортированной части и
вставляет его на правильное место в отсортированной части. javarush.com
Принцип работы:
Начинают со второго элемента массива (первый элемент считается отсортированным).
Сравнивают текущий элемент с предыдущими и перемещают его влево, пока не найдут правильное
место.
Повторяют процесс для всех элементов массива, вставляя каждый новый элемент на правильное место в
уже отсортированной части массива.
21. Сортировка массивов. Сортировка выбором
Сортировка выбором (Selection Sort) — алгоритм сортировки массивов, который находит наименьший
(или наибольший) элемент и перемещает его в начало (или конец). Процесс повторяется, пока все
элементы не окажутся упорядоченными.
Принцип работы
Алгоритм разделяет массив на две части:
Отсортированный подсписок элементов, который строится слева направо в начале списка.
Подсписок оставшихся неотсортированных элементов, занимающий остальную часть списка.
22. Сортировка массивов. Быстрая сортировка
Быстрая сортировка (англ. Quicksort) — алгоритм сортировки массивов, основанный на принципе
«разделяй и властвуй». Разработан британским учёным Тони Хоаром в 1960 году.
Принцип работы
Алгоритм состоит из трёх шагов:
Выбрать опорный элемент. Это может быть первый, последний или случайный элемент массива.
Разделить массив на две части. Элементы, меньшие опорного, помещаются перед ним, а большие или
равные — после.
Рекурсивно применить те же шаги к двум подмассивам слева и справа от опорного элемента.
23. Сортировка массивов. Сортировка слиянием
Сортировка слиянием (англ. Merge sort) — алгоритм сортировки массивов, основанный на
принципе «разделяй и властвуй».
Принцип работы
Алгоритм включает два основных этапа:
Разделение. Массив рекурсивно делится на две равные (или почти равные) части до тех пор, пока
каждый подмассив не будет состоять из одного элемента.
Слияние. Подмассивы объединяются в отсортированном порядке, начиная с самых маленьких
подмассивов.
24. Методы. Перегрузка методов
Перегрузка методов (method overloading) — это возможность создания в классе нескольких
методов с одинаковым именем, но с разными параметрами. Это позволяет использовать одно
имя метода для выполнения различных функций в зависимости от переданных аргументов.
Правила перегрузки методов
Имя метода должно быть одинаковым. Перегружаемые методы должны иметь одно и то же имя, чтобы
компилятор знал, что они — варианты одного метода.
Параметры должны быть разными. Перегружаемые методы должны иметь разное количество
аргументов, разные типы данных или порядок аргументов.
Возвращаемый тип метода не имеет значения. Два метода с одинаковым именем и параметрами, но
разными возвращаемыми типами, не будут считаться перегруженными.
Область видимости метода не имеет значения. Перегрузка методов не зависит от модификаторов
доступа (public, private, protected).
25. Параметры методов. Параметры переменной длины.
Параметры методов — это переменные, которые описываются при объявлении метода и
используются для передачи данных.
Параметры переменной длины (аргументы переменной длины, varargs) — это аргументы,
количество которых может меняться при вызове метода. Такие методы позволяют принимать
произвольное число аргументов одного типа.
26. Оператор return
Оператор return завершает выполнение функции и «возвращает» результат вызывающему
коду. После этого управление переходит в точку, откуда была вызвана функция, а инструкции
после return не выполняются.
27. Рекурсия
Рекурсия в программировании — это метод, при котором функция вызывает саму себя для решения
задачи. Это позволяет разбить сложную задачу на более простые подзадачи.
Принцип работы рекурсии
Рекурсия строится на двух ключевых принципах:
Базовый случай — условие, при котором рекурсивный вызов прекращается. Например, в задаче
вычисления факториала базовым случаем будет число 0, которое равно 1.
Рекурсивный вызов — часть функции, где она вызывает саму себя с новыми аргументами. Важно,
чтобы каждый рекурсивный вызов приближал задачу к базовому случаю, иначе функция может
зациклиться.
28. Классы, объекты, конструкторы
Классы, объекты и конструкторы — понятия, которые используются в объектноориентированном программировании (ООП).
Класс — это шаблон, в котором описаны общие черты и действия объекта (объектов). Он
определяет свойства и методы, которыми обладают объекты данного класса. Класс нужен для
объединения связанных данных и функций в одну логическую единицу, создания собственных
типов данных с нужным поведением и т. д..
Объект — это экземпляр класса, созданный в памяти. Он обладает конкретными свойствами и
поведением. Объекты нужны для хранения значений свойств, вызова методов с конкретными
данными и взаимодействия между разными частями программы через чётко определённый
интерфейс.
Конструктор — это специальный метод, автоматически вызываемый при создании объекта. Он
нужен для инициализации полей объекта начальными значениями, проверки корректности
создаваемого объекта, выделения ресурсов, необходимых объекту (память, файлы, соединения)
и т. д.. Конструктор имеет то же имя, что и класс, но у него нет типа возвращаемого значения.
29. Исключения
Исключения в программировании (exceptions) — это механизм, который позволяет программе
обрабатывать нетипичную ситуацию и при этом не прекращать работу. Благодаря этому
механизму разработчик может описать в коде реакцию программы на такие ситуации.
Виды исключений
Исключения делятся на два основных типа: ru.wikipedia.org*
Синхронные. Могут возникнуть только в определённых, заранее известных точках программы. Например,
ошибка чтения файла или коммуникационного канала, нехватка памяти. ru.wikipedia.org*
Асинхронные. Могут появляться в любой момент времени и не зависят от того, какую конкретно
инструкцию программы выполняет система. Типичные примеры: аварийный отказ питания или
поступление новых данных.
30. Иерархия исключений
Иерархия исключений в Java представляет собой древовидную структуру классов исключений, где
каждый класс наследуется от своего родительского класса. dzen.ru
На вершине иерархии находится класс Throwable, который является родительским для всех классовисключений.
Основные классы исключений
От класса Throwable наследуются два основных подкласса:
Error. Представляет фатальные ошибки, которые обычно не могут быть обработаны программой,
например, ошибки виртуальной машины или ошибки памяти.
Exception. Описывает возможные ошибки, которые могут возникнуть в процессе выполнения программы
и обычно могут быть обработаны.
31. Ключевое слово this. Инициализаторы.
Ключевое слово this в программировании, например в языке Java, представляет ссылку на текущий
экземпляр объекта. С его помощью можно обращаться к переменным и методам объекта, а также
вызывать его конструкторы.
В основном ключевое слово this используется в двух случаях:
Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена. В
таком случае this указывает, что вызывается поле класса, а не переменная метода.
Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или
параметризированный) из другого. Это ещё называется явным вызовом конструктора.
32. Пакеты
Пакеты в программировании — это механизм группировки связанных классов и интерфейсов,
который позволяет структурировать код внутри проекта или библиотеки. Они помогают избежать
конфликтов имён между классами и контролировать доступ к элементам кода.
Пакеты в Java
В Java пакеты создаются с помощью ключевого слова package в начале файла. Имя пакета обычно
следует обратной записи доменного имени, чтобы гарантировать уникальность.
Некоторые типы пакетов в Java:
Встроенные. Содержат базовые классы, например java.lang (автоматически импортируется) или
java.io для ввода-вывода.
Пользовательские. Позволяют создавать собственные группы классов и интерфейсов.
33. Статический импорт
Статический импорт в Java — это механизм, который позволяет обращаться к статическим членам
класса (методам и переменным) напрямую, без указания имени класса.
geeksforgeeks.orgmedium.comjavagists.com
Для статического импорта используется ключевое слово import static вместе с оператором
34. Инкапсуляция. Модификаторы доступа
Инкапсуляция — это механизм, который объединяет данные (атрибуты) и методы (функции) в
одном объекте и ограничивает прямой доступ к внутреннему состоянию.
Модификаторы доступа — это ключевые слова, которые определяют видимость и доступность
элементов класса (полей и методов).
public — поля и методы доступны из любого места, как внутри класса, так и за его пределами.
popov.devnetology.ru
private — члены класса доступны только внутри самого класса. popov.devnetology.ru
protected — доступ внутри класса, его пакета и подклассов. popov.devnetology.ru
default (без модификатора) — доступ внутри класса и его пакета, но не для подклассов вне пакета.
35. Статические члены. Модификатор static
Статические члены класса — это его методы или свойства, к которым можно обратиться без
создания объекта (экземпляра) данного класса. Такие члены данных разделяются всеми
экземплярами класса и хранятся в одном месте.
Модификатор static используется для создания членов класса, которые принадлежат не
конкретному объекту, а самому классу. Это означает, что данные и функции могут быть
использованы без создания экземпляра класса.
36. Внутренние и вложенные классы
Внутренние классы — когда объект внутреннего класса связан с объектом обрамляющего
класса. Не статические вложенные классы называются внутренними классами, если они
связанны с внешним классом. Локальные классы — объявленные внутри блока кода и не
являющиеся членом обрамляющего класса. В этом случае можно рассматривать класс как
локальную переменную типа класс.
37. Наследование. Правила наследования
Наследование в программировании — это принцип объектно-ориентированного
программирования (ООП), который позволяет создавать иерархии классов: дочерние классы
могут наследовать данные и методы от родительских классов.
Основные принципы наследования
Подкласс получает доступ ко всем публичным и защищённым членам суперкласса. Это позволяет
создавать более специализированные классы на основе общих шаблонов.
Дочерние классы могут расширять функциональность родительских — иметь собственные поля и
методы.
Изменения в суперклассе автоматически распространяются на все подклассы. Это упрощает
поддержку и обновление кода.
Виды наследования
Простое (одиночное). Дочерний класс наследует все свойства и методы родительского класса.
Множественное. Класс может наследовать свойства и методы более чем от одного родительского
класса. Это увеличивает гибкость, но также добавляет сложность и потенциальные конфликты из-за
перекрывающихся имён.
38. Переопределение методов
Переопределение методов в объектно-ориентированном программировании — это
возможность подкласса (дочернего класса) предоставить собственную реализацию метода, уже
определённого в родительском классе.
39. Абстрактный класс
Абстрактный класс в объектно-ориентированном программировании (ООП) — базовый класс,
который нельзя создать напрямую. Он служит основой для других классов, определяя общие
характеристики и поведение.
Зачем нужен абстрактный класс
Создание общего интерфейса для группы объектов. Это делает код более чистым и поддерживаемым.
Устранение дублирования кода за счёт того, что в абстрактном классе можно реализовать методы,
которые будут использоваться в подклассах.
Улучшение структуры кода за счёт создания «групп» подклассов, которые наследуют от одного
абстрактного класса. Такой код легче расширять, не внося изменений в уже существующую программу.
40. Класс String
Класс String в Java предназначен для работы со строками — объектами, представляющими
последовательность символов.
Особенности класса
Неизменяемость (immutable). После создания объекта его содержимое нельзя изменить. Любые
операции над строкой, которые меняют её, создают новый объект.
Потокобезопасность. Объекты класса String можно использовать в многопоточной среде.
Создание строк из разных источников. Можно использовать строковые литералы (последовательность
символов в двойных кавычках) или конструкторы, которые позволяют создать строку из массива символов
или байтов.
41. Сравнение строк
Для сравнения строк в Java на русском языке используются методы equals(),
equalsIgnoreCase(), оператор == и метод compareTo().
Метод equals()
Сравнивает содержимое двух строк. Если строки равны, метод возвращает true, в противном случае —
false.
Метод equalsIgnoreCase()
Сравнивает две строки, игнорируя регистр символов. Две строки считаются равными, если они имеют
одинаковую длину и соответствующие символы равны, независимо от регистра букв.
Оператор ==
Проверяет ссылочное равенство двух строк. Если две переменные указывают на один и тот же объект
(адрес памяти), оператор вернёт true. Однако если строки созданы с использованием разных операторов
или методов, даже если они содержат одинаковые значения, оператор == вернёт false.
Метод compareTo()
Сравнивает две строки лексикографически. Он возвращает целое число:
0, если строки равны; awilum.rudzen.ruw3resource.com
Отрицательное число, если вызывающая строка меньше строки, переданной в качестве аргумента;
awilum.ruw3resource.com
Положительное число, если вызывающая строка больше строки, переданной в качестве аргумента.
42. StringBuffer и StringBuilder. Конструкторы
У классов StringBuffer и StringBuilder в Java есть конструкторы, которые позволяют
создавать объекты этих классов. Однако у них есть различия: StringBuffer синхронизирован, а
StringBuilder — нет
StringBuffer() — создаёт пустой объект с начальной ёмкостью 16 символов.
StringBuilder() — создаёт пустой объект с начальной ёмкостью по умолчанию 16 символов.
43. Методы удаления символов
В Java для удаления символов из строк используются методы класса String, а также класс
StringBuilder
Метод substring()
Метод substring(int start, int end) возвращает подстроку из исходной строки с позиции start
(включительно) до end (не включительно).
Метод replace()
Метод replace() класса String принимает два аргумента: символ, который необходимо удалить, и символ,
на который нужно заменить удаляемый символ.
Метод StringBuilder
Метод delete() класса StringBuilder удаляет подстроку из текущей последовательности символов.
44. Многопоточные приложения
Многопоточные приложения (multithreading) — это программы, которые способны выполнять несколько
задач одновременно. Это достигается за счёт создания потоков (threads) — самостоятельных единиц
выполнения в рамках одного процесса.
Основные концепции
Параллелизм. Потоки могут выполняться параллельно на одном процессоре, хотя фактически не
выполняются одновременно — процессор быстро переключается между потоками, создавая иллюзию
параллельного выполнения.
Синхронизация. Позволяет управлять ходом выполнения программы и доступом к общим данным для
одновременно выполняющихся потоков. Для синхронизации используются мьютексы, условные
переменные и семафоры.
45. Отличие класса String от StringBuffer и StringBuilder
Таким образом, String подходит для работы со строками, которые не изменяются, а
StringBuffer и StringBuilder — для частого изменения строки в цикле или при выполнении
множественных операций со строками, а StringBuilder — если не нужны функции
многопоточности.
46. Регулярные выражения. Метасимволы, квантификаторы
Регулярные выражения (regex) — это шаблоны для поиска фрагментов текста. В них используются
метасимволы и квантификаторы, которые задают поведение поиска.
Метасимволы
Метасимволы — это специальные символы, которые имеют особое значение в синтаксисе регулярных
выражений. Некоторые из них:
^ — начало строки;
$— конец строки;
\b — граница слова;
\d — любая цифра;
\D — любой символ, кроме цифр;
\w — любая буква, цифра или знак подчёркивания;
\W — любой символ, кроме \w.
Квантификаторы
Квантификаторы — это метасимволы, которые указывают количество повторений символа или группы
символов в строке. Некоторые из них:
«*» — любое количество вхождений;
«+» — одно или более вхождений;
«?» — ноль или одно вхождение;
«{n}» — точное количество повторений;
«{n,}» — минимальное количество повторений;
«{n,m}» — от n до m повторений.
47. Регулярные выражения. Группировка
Группировка в регулярных выражениях позволяет определить подвыражения (группы) и
зафиксировать подстроки входной строки. Группы обозначаются круглыми скобками «()».
Нумерованные группы
Группы нумеруются слева направо, начиная с 1. Группа 0 всегда соответствует всему выражению
целиком.
Именованные группы
Группе можно присвоить имя, чтобы удобнее к ней обращаться.
48. Регулярные выражения. Класс Pattern
Класс Pattern в регулярных выражениях Java (пакет java.util.regex) представляет
скомпилированное представление регулярного выражения (шаблона).
Методы класса Pattern
Некоторые методы класса Pattern:
compile(String regex) — компилирует указанное регулярное выражение в шаблон.
geeksforgeeks.orgdocs.oracle.com
compile(String regex, int flags) — компилирует регулярное выражение с учётом заданных флагов.
javarush.comgeeksforgeeks.org
matches(String regex, CharSequence input) — проверяет, соответствует ли последовательность
символов шаблону. metanit.comdocs.oracle.com
pattern() — возвращает регулярное выражение, из которого был скомпилирован шаблон.
geeksforgeeks.orgdocs.oracle.com
split(CharSequence input) — разбивает строку на подстроки, используя указанный в шаблоне
разделитель.
49. Модель безопасности java. Надежность языка
Модель безопасности языка Java основана на сочетании встроенных механизмов, которые
обеспечивают надёжность программ, написанных на этом языке. Однако важно учитывать, что Java не
является абсолютно безопасным языком, и ответственность за безопасность приложений лежит не
только на языке, но и на разработчиках.
50. Модель безопасности java. Контроль при получении и загрузке программ
В модели безопасности Java предусмотрен многоступенчатый контроль при получении и
загрузке программ. Он направлен на защиту Java-окружения времени выполнения и ресурсов
аппаратно-программной платформы от вредоносного программного обеспечения, а также на
разграничение доступа субъектов к ресурсам прикладного уровня.
51. Модель безопасности java. Контроль при выполнении
Контроль при выполнении программ в модели безопасности Java включает механизмы,
которые обеспечивают защиту Java-окружения от вредоносного программного обеспечения и
разграничение доступа к ресурсам.
Основные механизмы
Контроль при выполнении программ в Java делится на два уровня:
Нижний уровень — виртуальная Java-машина не допускает выходов за границы массивов и аналогичных
некорректных действий.
Верхний уровень — менеджер безопасности выполняет содержательные проверки правомерности
доступа, реализуя выбранную политику безопасности.
52. Методы работы с регулярными выражениями
Методы работы с регулярными выражениями включают создание шаблонов, поиск
совпадений и обработку ошибок.
53. Поток ввода/вывода
STDIN (Standard Input) — стандартный поток ввода, STDOUT (Standard Output) — стандартный
поток вывода.
STDIN предназначен для чтения команд пользователя или входных данных. По умолчанию он нацелен на
чтение со стандартного устройства ввода (клавиатуры). ru.wikipedia.org*
STDOUT используется для вывода данных, как правило, текстовых. При интерактивном запуске
программы по умолчанию он направлен на запись на устройство отображения (монитор). Однако в
некоторых системах (например, UNIX) этот поток можно перенаправить в файл с помощью символа «>».
54. Потоки байтов и символов
В программировании выделяют два типа потоков: байтовые и символьные. Они
используются для ввода-вывода данных, но работают с разными типами информации.
Потоки байтов
Байтовый поток (binary-stream) содержит последовательность байтов (8-битную информацию). Он
позволяет читать и записывать байты из различных источников, например файлов, сетевых сокетов,
массивов
InputStream — для чтения байтов (ввод);
OutputStream — для записи байтов (вывод).
Потоки символов
Символьный поток (text-stream) содержит последовательность символов (обычно 16-битовых символов
Unicode). Он позволяет читать и записывать символы из текстовых файлов, строк, сокетов.
Reader — для чтения символов (ввод);
Writer — для записи символов (вывод).
55. Типы потоков
Байтовые потоки
Байтовые потоки работают с данными, представленными в виде байтов (двоичных данных). В языках
программирования для их реализации используются специальные классы, например:
InputStream — для чтения байтов;
OutputStream — для записи байтов.
Особенность байтовых потоков — данные из них можно читать или записывать только последовательно:
нельзя прочитать данные из середины потока, не прочитав все данные перед ними.
Символьные потоки
Символьные потоки работают с данными, представленными в виде символов (например, текстовых). В
языках программирования для их реализации также используются специальные классы, например:
Reader — для чтения символов;
Writer — для записи символов.
В некоторых языках, например в C++, существуют стандартные символьные потоки: cin для ввода с
клавиатуры и cout для вывода на экран.
Потоки ввода-вывода
Потоки ввода-вывода (I/O-потоки) — это абстрактное понятие, которое описывает процесс обмена
данными между программой и внешним миром. Они делятся на три типа:
Входные — данные поступают в программу, из них читается информация.
Выходные — данные предоставляются конкретному потребителю: монитору, файлу, принтеру и т. д..
Двунаправленные — допускают как чтение, так и запись.
56. Варианты передачи информации
Варианты передачи информации могут быть следующими:
По направлению передача информации бывает:
Симплексная. Только в одном направлении, например, радиотрансляция.
Полудуплексная. В обоих направлениях, но поочерёдно, пример — работа раций.
Дуплексная. Двусторонняя, где обмен данных происходит одновременно, например, оптоволоконные
каналы или телефонная связь.
dwdm.me
По среде передача информации бывает:
Проводная. Осуществляется через физические линии, например, через оптоволокно, коаксиальный
кабель или витую пару.
Беспроводная. Предполагает использование инфракрасного, лазерного излучения или радиоволн,
например, передача данных по Bluetooth, Wi-Fi, спутниковой связи.
57. Основные действия с потоком
Основные действия с потоком включают создание потока, управление его работой и
завершение. Эти действия зависят от языка программирования и могут осуществляться через
специальные механизмы.
58. Закрытие потоков. Утечка памяти
Незакрытие потоков в Java может привести к утечке памяти. Это происходит, когда объекты, которые
больше не используются, продолжают храниться в памяти, так как на них есть ссылки в других местах.
Причины утечек памяти
Каждый открытый поток занимает память, и если её не освободить, она остаётся занятой. Это может
произойти даже в случае исключения, которое не позволяет программе выполнить код для закрытия
потока.
Как предотвратить утечки памяти
Чтобы предотвратить утечки памяти из-за незакрытых потоков, рекомендуется:
Использовать блок finally для закрытия ресурсов, включая потоки.
Не допускать необработанных исключений в коде, который закрывает ресурсы.
В Java 7 и выше использовать конструкцию try-with-resources, которая автоматически вызывает
метод close() у ресурса после завершения блока
59. Способы закрытия потоков
В Java для закрытия потоков (ресурсов) используются метод close(), конструкция try-withresources и метод interrupt()
60. Запись текста через буфер
Java. Использует класс BufferedWriter, который записывает текст в поток, предварительно
буферизируя символы. Пример записи в файл: BufferedWriter bw = new BufferedWriter(new
FileWriter("notes4.txt")); bw.write(text)
61. Чтение текста в консоль
Прочитать текст с консоли можно в разных языках программирования, например, в Java и C#. Ниже
приведены примеры на этих языках. baeldung.commedium.com
Java
В Java для чтения текста с консоли используется класс Scanner. Чтобы создать его экземпляр, нужно
передать в качестве источника ввода стандартный поток System.in. sky.prokedu.ru
Некоторые методы класса Scanner:
nextLine — считывает строку, включая пробелы, до символа новой строки;
next — читает строку до первого пробела или перевода;
nextInt — считывает целое число;
nextDouble — считывает число с плавающей запятой.
62. Чтение текста в файл
Для чтения текста из файла в программировании на Java можно использовать классы Reader или
BufferedReader. Выбор метода зависит от задачи и требований к производительности.
Использование класса Reader
Класс Reader — абстрактный класс, который определяет базовые методы для работы с текстовыми
данными. Для чтения текста из файла обычно используют его подклассы, например FileReader.
kedu.ruscientecheasy.com
Некоторые особенности класса Reader:
Читает символы по одному с помощью метода read().
Не поддерживает буферизацию, частые вызовы метода read() могут снижать производительность.
63. Работа с файлами и каталогами
Для работы с файлами и каталогами в программировании используются различные
библиотеки и методы, которые зависят от языка. Ниже приведены примеры в Python, а также
общие подходы в разных языках.
64. Абсолютный, относительный, абстрактный путь
Абсолютный путь — полный путь, который указывает местоположение файла или каталога от корневого
каталога («/»). Такой путь не зависит от текущего рабочего каталога. Он всегда начинается с корневого
каталога, за которым следуют подкаталоги, и заканчивается именем желаемого файла или каталога.
Пример: /home/anshu/scripts/myscript.sh. geeksforgeeks.org
Относительный путь — это «маршрут» к документу относительно текущего каталога. Текущий каталог
— тот, в котором запускается программа, скрипт или открывается страница в браузере. Относительный
путь ссылается на местоположение относительно текущей директории. Для работы с такими путями
используют специальные символы: точку «.» для перехода в текущий каталог и двойную точку «..» для
перехода в родительский каталог. otus.ru
Абстрактный путь — это путь к файлу, который может быть как абсолютным, так и относительным.
Например, в Java есть метод getPath(), который возвращает абстрактный путь к имени файла в виде
строки.
65. Методы isDirectory()/isFile()
Методы isDirectory() и isFile() — это методы класса File в языке Java, которые проверяют,
представляет ли объект файл или каталог.
Метод isDirectory()
Возвращает true, если объект класса File указывает на каталог, и false в противном случае.
Метод isFile()
Возвращает true, если объект класса File представляет файл, и false если путь указывает на каталог.
66. Конструкторы класса File.
Класс File в Java предоставляет несколько конструкторов для создания объектов, представляющих
файлы и каталоги. proglang.suw3schools.tech
Описание конструкторов
File(String pathname). Создаёт новый экземпляр файла, преобразуя указанную строку пути в
абстрактный путь.
File(String parent, String child). Создаёт новый экземпляр файла из строки родительского пути и строки
пути потомка.
File(File parent, String child). Создаёт новый экземпляр файла из абстрактного родительского пути и
строки пути потомка.
File(URI uri). Создаёт новый экземпляр файла, преобразуя указанный объект URI в абстрактный путь.
67. Сериализация и десериализация объектов. Класс ObjectOutputStream
Класс ObjectOutputStream в Java используется для сериализации объектов — сохранения их
состояния в последовательность байтов для передачи или сохранения. Десериализация —
процесс восстановления объекта из этих байтов.
68. Сериализация и десериализация объектов. Класс ObjectInputStream
Сериализация и десериализация объектов в Java позволяют преобразовать объект в
байтовый поток и восстановить его обратно в объект. Эти процессы используются для
сохранения состояния объектов или передачи их по сети.
Процесс сериализации
Сериализация — процесс сохранения состояния объекта в последовательность байтов. Для
сериализации объект должен реализовать интерфейс java.io.Serializable. Этот интерфейс не определяет
методов, но указывает JVM, что объекты этого класса можно сериализовать.
Процесс десериализации
Десериализация — процесс восстановления объекта из потока байтов. Входными данными для
десериализации является поток байтов, который содержит информацию об объекте: метаданные класса,
данные о типе полей и значения полей.
Класс ObjectInputStream
Класс ObjectInputStream отвечает за чтение ранее сериализованных данных из потока. В конструкторе
он принимает ссылку на поток ввода: ObjectInputStream(InputStream in). metanit.comjava-online.ru
Основной метод класса — readObject(), который читает объект из потока и возвращает его.
Возвращённое значение необходимо привести к соответствующему типу данных.
69. Лямбда выражение. Синтаксис и использование.
Лямбда-выражение — это набор инструкций, которые можно выделить в отдельную переменную и затем
многократно вызвать в различных местах программы. Лямбда-выражения позволяют написать метод и
сразу же использовать его, что сокращает время на объявление и написание метода без необходимости
создавать класс.
Синтаксис
Лямбда-выражение состоит из трёх частей:
Параметры — входные данные, указаны в скобках.
Стрелка (->) — отделяет параметры от тела выражения.
Тело — код, который определяет действие лямбда-выражения. Оно может быть одним выражением или
блоком кода, заключённым в фигурные скобки.
70. Лямбда выражение. Отложенное выполнение
Отложенное выполнение (deferred execution) — одна из важных особенностей лямбдавыражений. Суть в том, что лямбда-выражение не выполняется в момент объявления, а его
выполнение откладывается до вызова метода, который использует эту лямбду. По сути, лямбда
сохраняется как ссылка на код и выполняется только тогда, когда это необходимо.
71. Лямбда выражение. Передача параметров
Лямбда-выражение — это анонимная функция, которая представляет набор инструкций и может
быть передана как аргумент другой функции или использоваться в качестве значения
переменной функционального типа.
72. Лямбда выражение. Локальные переменные
Лямбда-выражения могут использовать локальные переменные, объявленные в внешней
области видимости: на уровне метода или класса, в котором определено выражение
73. Функциональные интерфейс. Встроенные функциональные интерфейсы
Функциональный интерфейс в Java — это интерфейс с одним абстрактным методом. Он может
содержать любое количество статических и дефолтных методов.
UnaryOperator<T>. Принимает в качестве параметра объект T, выполняет над ним некоторые операции и
возвращает результат операций в виде объекта того же типа.
BinaryOperator<T>. Принимает два аргумента типа T и возвращает объект того же типа.
74. Обощенный функциональные интерфейс
Возможно, имелись в виду функциональные интерфейсы в Java. Это интерфейсы, которые
содержат только один абстрактный метод и используются для реализации концепций
функционального программирования
75. Интерфейсы. Отличие от класса
Основные отличия интерфейсов от классов:
Назначение: классы определяют состояние поведения объектов, а интерфейсы — набор методов,
которых должны придерживаться реализующие классы. popov.devgeeksforgeeks.org
Описание категории объектов: классы могут описывать целую категорию разных объектов, а их
характеристики имеют право наследовать только те объекты, которые являются частью этой категории.
Интерфейсы описывают только часть функциональности объекта — определённые признаки. skillbox.ru
Наличие полей: интерфейс описывает только поведение (методы), и у него нет полей. В то же время
класс может содержать поля, которые будут принадлежать разным объектам. skillbox.ru
Наследование: наследник класса обязан наследовать все его составляющие, а интерфейс создан только
для реализации (имплементирования)
76. Интерфейсы. Методы по умолчанию
Интерфейс — это способ взаимодействия между человеком и устройством, программой
или системой. Проще говоря, это то, как мы общаемся с техникой: кнопки на пульте, экран
смартфона, голосовой помощник, даже джойстик от игровой приставки — всё это интерфейсы
Методы по умолчанию (default methods) в интерфейсах Java — это методы, которые могут
быть определены в интерфейсе с реализацией по умолчанию. Они позволяют добавлять новые
методы в существующие интерфейсы без необходимости изменения всех реализаций этого
интерфейса.
77. Интерфейсы. Приватные методы
Интерфейс — это способ взаимодействия между человеком и устройством, программой
или системой. Проще говоря, это то, как мы общаемся с техникой: кнопки на пульте, экран
смартфона, голосовой помощник, даже джойстик от игровой приставки — всё это интерфейсы
Приватные методы в интерфейсах Java — это методы, которые позволяют скрывать реализацию, если
она нужна только внутри интерфейса. Они были введены в Java 9.
Определение приватных методов
Приватные методы определяются с помощью модификатора private в объявлении интерфейса. Они
могут быть статическими и нестатическими.
78. Анонимные классы
Анонимные классы в языке Java — это классы, созданные без указания имени. Они
объявляются и создаются одновременно в месте, где используются. Внешне анонимный класс
выглядит как обычный класс, но без имени
79. Перечисление enum
Перечисление (enum) — это пользовательский тип данных, который состоит из набора
именованных констант, называемых перечислителями. Они часто используются для
представления наборов связанных значений, таких как дни недели, месяцы или состояния
Синтаксис объявления
Перечисление объявляется с помощью ключевого слова enum. Общая форма объявления зависит от
языка программирования, например:
В Java: enum Enum_name { ENUM_CONSTANT_1, ENUM_CONSTANT_2, ... };.
80. Методы перечислений equals() и hashCode()
Метод equals()
Проверяет объекты на равенство по содержанию, возвращая true при равенстве или false при
неравенстве. gitverse.rudzen.ru
Для перечислений метод equals() сравнивает ссылки на константы. Это связано с тем, что значения в
перечислениях уникальны (константны), и любая ссылка на них указывает на один и тот же объект в
памяти.
Метод hashCode()
Генерирует целочисленный хеш-код для объекта, который используется для поиска в хеш-таблицах и
коллекциях. gitverse.rudzen.ru
Для перечислений метод hashCode() возвращает хеш-код для конкретной константы. По умолчанию
он использует стандартную реализацию из класса Object, но в пользовательских классах метод можно
переопределить, чтобы он генерировал уникальный код на основе значимых полей объекта.
81. Обобщения
Обобщение — это мыслительная операция, при которой различные предметы
объединяются в единый класс на основе общего признака, а также результат такой
операции — общее положение, вывод.
Виды обобщения
Некоторые виды обобщения по способу проведения:
Эмпирические. Основаны на непосредственно наблюдаемых свойствах объектов.
Теоретические. Предполагают выделение существенных связей как внутри объекта, так и между
объектами внешнего мира.
Процесс обобщения
Обобщение — сложный когнитивный процесс, при котором человек выделяет главные характеристики
объекта, явления или ситуации, отбрасывая второстепенные детали.
Процесс обобщения можно представить как многоуровневую пирамиду, где основание образуют
конкретные факты и наблюдения, а вершина — самое широкое понятие или правило. Каждый уровень
формируется через анализ общих черт и свойств нижележащих элементов.
Примеры обобщения
«Все кошки — млекопитающие».
«Все планеты вращаются вокруг Солнца».
«Все люди стремятся к счастью».
«Роза, гвоздика, ромашка — это цветы» (слово «цветы» — обобщение).
82. Класс Object
Класс Object в Java — корневой класс иерархии классов. Все остальные классы в языке
являются подклассами этого класса, непосредственно или косвенно.
83. Клонирование объектов
Клонирование объектов — процесс создания точной копии существующего объекта. Это
понятие встречается в разных языках программирования, например, в JavaScript и Java.
84. Паттерны. Порождающие паттерны
Порождающие паттерны (Creational patterns) — это шаблоны проектирования, которые
определяют, как создавать объекты и классы в системе. Они помогают избежать прямой
зависимости между компонентами и облегчают добавление новых объектов без изменения
существующего кода.
«Фабричный метод» (Factory Method). Определяет интерфейс для создания объектов, но позволяет
подклассам выбирать класс создаваемого экземпляра.
«Абстрактная фабрика» (Abstract Factory). Предоставляет интерфейс для создания семейств
взаимосвязанных объектов, не специфицируя их конкретные классы.
«Одиночка» (Singleton). Гарантирует, что у класса есть только один экземпляр, и предоставляет
глобальную точку доступа к этому экземпляру.
«Строитель» (Builder). Предоставляет способ создания сложных объектов, позволяя разбить процесс
создания на отдельные шаги.
«Прототип» (Prototype). Позволяет создавать новые объекты путём копирования уже существующих
объектов.
85. Паттерны. Структурные паттерны
Структурные паттерны (шаблоны проектирования) определяют способы организации связей
между классами и объектами для формирования более сложных структур. Они помогают решать
задачи, связанные с композицией объектов, агрегацией и наследованием.
Основные структурные паттерны
Некоторые структурные паттерны:
«Адаптер» (Adapter) — преобразует интерфейс одного класса в другой, обеспечивая совместную работу
несовместимых классов.
«Мост» (Bridge) — разделяет абстракцию и реализацию, позволяя им изменяться независимо.
«Компоновщик» (Composite) — объединяет объекты в древовидные структуры для представления
иерархий «часть-целое».
«Декоратор» (Decorator) — динамически добавляет объектам новые функциональные возможности,
оборачивая их в классы-декораторы.
«Фасад» (Facade) — предоставляет упрощённый интерфейс к сложной системе классов, скрывая её
сложность.
«Лёгковес» (Flyweight) — поддерживает множество мелких объектов, разделяя общее состояние.
«Заместитель» (Proxy) — контролирует доступ к объекту через объект-заместитель.
86. Паттерны. Поведенческие
Поведенческие паттерны — это повторяющиеся последовательности действий или реакций,
которые человек проявляет в разных ситуациях. Слово «паттерн» (pattern) переводится с
английского как «шаблон» или «образец».
Виды паттернов
Некоторые виды поведенческих паттернов:
Адаптивные. Способствуют успешной адаптации к окружающей среде и достижению целей. Например,
паттерн постоянного обучения.
Дисфункциональные. Могут препятствовать адаптации и достижению целей. Например, избегание
конфликтов.
Сознательные. Человек думает о своём поведении и принимает решение действовать определённым
образом.
Неосознанные. Основаны на глубоко укоренившихся убеждениях и прошлом опыте. Их сложно осознать
самостоятельно, обычно люди замечают их, когда получают обратную связь от других или во время
работы с психологом.
Межличностные. Проявляются во взаимодействии с другими людьми. Например, склонность к
компромиссу в конфликтных ситуациях.
Внутриличностные. Относятся к рефлексии и отношениям с собой. Например, человек обдумывает
происходящее и проживает эмоции внутри себя.
87. Паттерны. Паттерн фабрика
Паттерн «Фабрика» (Factory) — это порождающий паттерн проектирования, который создаёт
объекты суперкласса без указания их конкретного типа. Принцип работы построен на
использовании общего интерфейса или абстрактного класса, через который создаются разные
реализации объектов.
Виды паттерна Фабрика
Существует несколько разновидностей паттерна «Фабрика»:
Простая фабрика. Создаёт экземпляры для клиента без предоставления какой-либо логики. habr.com
Фабричный метод. Использует генерирующие методы для создания объектов без указания их
конкретных классов. dzen.ruhabr.com
Абстрактная фабрика. Позволяет создавать семейства связанных объектов, не привязываясь к
конкретным классам создаваемых объектов.
88. Шаги реализации паттерна фабрика
Реализация паттерна «Фабрика» (Factory) включает несколько шагов:
Создание абстрактной фабрики.
Реализация конкретных фабрик.
Использование фабрики в клиентском коде.
89. Паттерны. Паттерн одиночка
Singleton (с англ. — «одиночка») — это паттерн проектирования, гарантирующий, что у
класса будет только один экземпляр. К этому экземпляру предоставляется глобальная, то
есть доступная из любой части программы, точка доступа. Если попытаться создать новый
объект этого класса, то вернётся уже созданный существующий экземпляр
90. Шаги реализации паттерна одиночка
Шаги реализации паттерна «Одиночка» (Singleton):
Добавить в класс приватное статическое поле, которое будет содержать одиночный объект.
Объявить статический создающий метод, который будет использоваться для получения одиночки.
Добавить «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий
метод одиночки.
Сделать конструктор класса приватным. Это запрещает создание новых экземпляров того же класса.
В клиентском коде заменить вызовы конструктора одиночки вызовами его создающего метода.
91. Паттерны. Паттерн наблюдатель
Паттерн «Наблюдатель» (Observer) — это поведенческий паттерн проектирования, который
позволяет объектам подписываться на события другого объекта и получать уведомления об
изменениях его состояния.
Принцип работы
Подписка. Наблюдатели добавляют себя в список наблюдателей субъекта.
Изменение состояния. Когда состояние субъекта изменяется, он уведомляет всех своих наблюдателей.
Обновление. Каждый наблюдатель получает уведомление и обновляет своё состояние в соответствии с
изменениями субъекта.
92. Шаги реализации паттерна наблюдатель
Некоторые шаги реализации паттерна «Наблюдатель» (Observer):
Реализовать класс Subject. Это сущность издателя, изменения в которой транслируются всем
наблюдателям. В классе нужно реализовать методы, которые позволяют добавлять, удалять
наблюдателей и оповещать их об изменениях состояния.
Создать абстрактный класс Observer. Он представляет сущность наблюдателя (слушателя), которая
позволяет принимать сообщения от Subject. В классе нужно определить метод update, который будет
вызываться Subject при изменении его состояния.
Создать конкретные классы наблюдателей, которые наследуются от Observer. Каждый из таких
классов должен включать бизнес-логику в метод update.
Использовать созданные классы. С помощью метода attach наблюдатели регистрируются у Subject.
Когда состояние Subject меняется, вызывается метод notify, который проходит по списку наблюдателей и
вызывает метод update у каждого из них.
93. Паттерны. Паттерн адаптер
Паттерн «Адаптер» (Adapter) — это структурный паттерн проектирования, который позволяет объектам
с несовместимыми интерфейсами работать вместе. Он выступает в роли посредника, преобразуя
интерфейс одного объекта в интерфейс, понятный другому. refactoring.gururu.wikipedia.org*dzen.ru
Структура паттерна
Существует два основных варианта реализации паттерна «Адаптер»:
Адаптер объектов. Использует композицию: адаптер содержит ссылку на экземпляр адаптируемого
класса.
Адаптер классов. Базируется на наследовании: адаптер наследует интерфейсы как целевого, так и
адаптируемого классов. Этот подход возможен только в языках, поддерживающих множественное
наследование, например, C++
94. Шаги реализации паттерна адаптер
Шаги реализации паттерна «Адаптер»:
Убедиться, что есть два класса с несовместимыми интерфейсами. Один из них — полезный сервис,
который нельзя изменять, другой — один или несколько клиентов, классы приложения, несовместимые с
сервисом из-за неудобного или несовпадающего интерфейса.
Описать клиентский интерфейс, через который классы приложения смогут использовать класс сервиса.
Создать класс адаптера, реализовав этот интерфейс. На этом шаге все методы можно оставить
пустыми.
Добавить в класс адаптера поле, которое будет хранить ссылку на объект сервиса. Обычно это поле
заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект
можно передавать через параметры методов адаптера.
Реализовать все методы клиентского интерфейса в адаптере. Адаптер должен делегировать
основную работу сервису, обрабатывая только преобразование интерфейса или формата данных.
Сделать так, чтобы приложение использовало адаптер только через клиентский интерфейс. Это
позволит легко изменять и добавлять адаптеры в будущем.
